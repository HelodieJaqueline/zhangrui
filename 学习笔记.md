# 学习笔记、日常积累

## 计算机基础
### 网络

#### TCP/IP

### 操作系统
#### Linux
##### 常用命令


#### CPU

#### 内存

#### 磁盘

#### 线程

#### 进程

#### 死锁

### 数据结构和算法

算法题目积累: https://github.com/HelodieJaqueline/zhangrui.git

#### 数据结构

##### 数组

##### 链表

##### 队列

##### 字符串

##### 树

#### 算法

##### 排序

##### 动态规划

#### 查找

## 语言基础

### 集合框架

#### List

#### Set

#### Map

#### Queue

### 多线程并发

#### 多线程基础

#### 基本原理

#### 线程安全原理

#### AQS原理

#### 多线程并发工具类

#### ConcurrentHashMap原理

#### 阻塞队列及原子操作

#### 线程池原理

### JVM

JVM架构图
https://github.com/HelodieJaqueline/zhangrui/blob/master/JVM%E6%9E%B6%E6%9E%84%E5%9B%BE.png



#### 运行时数据区域

##### 程序计数器

* 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。
* 为了线程切换后能**恢复到正确的执行位置**，**每条线程**都需要有一个**独立**的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“**线程私有**”的内存。
* 程序计数器是**唯一一个不会出现 OutOfMemoryError 的内存区域**，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

##### Java虚拟机栈

*  与程序计数器一样，Java 虚拟机栈也是**线程私有**的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

* **Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

* **局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

  **Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

  1. **tackOverFlowError：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。
  2. **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。

##### 本地方法栈

* 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
* 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
* 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

##### 虚拟机栈中的各个部分

- 局部变量表：存放方法参数和方法内部定义的局部变量，以变量槽Slot为基本单位，一个Slot可以存放32位以内的数据类型，可重用。
- 操作数栈：先入后出，32位数据类型所占栈容量为1，64为数据类型所占栈容量为2
- 动态链接：常量池中符号引用有一部分在每次运行期间转换为直接引用，这部分称为动态链接。（一部分在类加载阶段或第一次使用时转换为直接引用—静态解析）
- 方法返回地址：方法执行后退出的两种方式：正常完成出口（执行引擎遇到任意一个返回的字节码指令）和异常完成出口（在方法执行过程中遇到异常且此异常未被处理）。两种方式都需要返回到方法被调用的位置程序才能继续执行（正常退出时调用者的PC计数器的值可以作为返回地址且栈帧中很可能保存这个计数器值；异常退出返回地址要通过异常处理器表来确定，栈帧中一般不会保存）。

##### Java堆

* Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**
* Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

##### 方法区

* 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

* **方法区和永久代的关系**:《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

* 相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

  JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

##### 运行时常量池

* 运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

* 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。
* DK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

##### 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。**

* JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。
* 本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

**Java中的引用**

- 强引用：new这类引用，只要强引用在，对象永远不会被回收。
- 软引用：描述有用但非必需的对象，在内存溢出之前，会把这些对象列入回收范围内进行第二次垃圾回收。
- 弱引用：描述非必需对象，只存活到下一次垃圾回收前。
- 虚引用：不会对生存时间造成影响，不能通过虚引用获得对象实例，只是在被虚引用的对象被回收时受到一个系统通知。

#### 常用参数

* 堆内存设置

#### GC

##### GC类型

##### GC算法

##### Minor GC和Full GC

- Minor GC：从新生代回收内存，关键是Eden区内存不足，造成不足的原因是Java对象大部分是朝生夕死(java局部对象)，而死掉的对象就需要在合适的时机被JVM回收
- Major GC：从老年代回收内存，一般比Minor GC慢10倍以上。
- Full GC：对整个堆来说的，出现Full GC通常伴随至少一次Minor GC，但非绝对。Full GC被触发的时候：老年代内存不足；持久代内存不足；统计得到的Minor GC晋升到老年代平均大小大于老年代空间。

##### Java虚拟机new一个对象的创建过程

- 在常量池中查看是否有new的参数对应的类的符号引用，并检查这个符号引用对应的类是否被加载、解析、初始化
- 加载后，为新对象分配内存空间，对象多需要的内存大小在类被加载之后就被确定（堆内分配内存：指针碰撞、空闲列表）。
- 将分配的空间初始化为零值。
- 对对象头进行必要设置（实例是哪个类的实例、类的元信息数据、GC分代年龄等）。
- 执行方法，按照程序的值初始化。



##### 垃圾收集器

#### 类加载

类加载过程主要包含加载、验证、准备、解析、初始化、使用、卸载七个方面

**一、加载**

在加载阶段，虚拟机主要完成三件事：

- 通过一个类的全限定名来获取定义此类的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区域的运行时数据结构。
- 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区域数据的访问入口

**二、验证**

　　验证阶段作用是保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害。如果验证失败，就会抛出一个java.lang.VerifyError异常或其子类异常。验证过程分为四个阶段

　　1.文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理。

　　2.元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范。

　　3.字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害虚拟机。

　　4.符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。

**三、准备**

　　准备阶段为变量分配内存并设置类变量的初始化。在这个阶段分配的仅为类的变量(static修饰的变量)，而不包括类的实例变量。对已非final的变量，JVM会将其设置成“零值”，而不是其赋值语句的值：

　　pirvate static int size = 12;

　　那么在这个阶段，size的值为0，而不是12。 final修饰的类变量将会赋值成真实的值。

**四、解析**

　　解析过程是将常量池内的符号引用替换成直接引用。主要包括四种类型引用的解析。类或接口的解析、字段解析、方法解析、接口方法解析。

**五、初始化**

　　在准备阶段，类变量已经经过一次初始化了，在这个阶段，则是根据程序员通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等。

##### 双亲委派模型

如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。 每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

**为什么需要双亲委派模型？**

在这里，先想一下，如果没有双亲委派，那么用户是不是可以 自己定义一个java.lang.Object的同名类 ， java.lang.String的同名类 ，并把它放到ClassPath中,那么 类之间的比较结果及类的唯一性将无法保证 ，因此，为什么需要双亲委派模型？ 防止内存中出现多份同样的字节码

**怎么打破双亲委派模型？**

打破双亲委派机制则不仅 要继承ClassLoader 类，还要 重写loadClass和findClass 方法。



#### 调优

##### Linux命令排查

- 使用**top**命令查看系统资源占用高的进程

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                                             
   4457 root      20   0 2458m 138m  13m S 98.5  7.4   0:33.72 java                                                                                                 
    1 root      20   0 19232  952  768 S  0.0  0.0   0:07.02 init     

- 使用 top -Hp 4457 命令

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                                             
   4520 root      20   0 2458m 141m  13m R 99.2  7.5   4:40.70 java                                                                                                 
   4457 root      20   0 2458m 141m  13m S  0.0  7.5   0:00.00 java  

  - 将线程id 4520转化为16进制:11a8

- 

##### Arthas

<https://github.com/alibaba/arthas>

##### Jprofile

#### JVM常见问题

##### 为什么要分为Eden和Survivor?为什么要设置两个Survivor区？
* 如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。 老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。
  Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
* 设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空； 等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）

##### JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代

当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。

大对象（需要大量连续内存空间的Java对象，如那种很长的字符串） 直接进入老年态 

如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1， 若年龄超过一定限制（15），则被晋升到老年态 。即 长期存活的对象进入老年态 。

老年代满了而 无法容纳更多的对象 ，Minor GC 之后通常就会进行Full GC，Full GC 清理整个堆内存– 包括年轻代和年老代 。

Major GC 发生在老年代的GC ， 清理老年区 ，经常会伴随至少一次Minor GC， 比Minor GC慢10倍以上 。

##### 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。

几种垃圾收集器：

| 名称              | 简介                                                         |
| ----------------- | ------------------------------------------------------------ |
| Serial            | 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。 |
| ParNew            | Serial收集器的多线程版本，也需要stop the world，复制算法。   |
| Parallel Scavenge | 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。 如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。 |
| Serial Old        | 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。 |
| Parallel Old      | 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。 |
| CMS               | 是一种以获得最短回收停顿时间为目标的收集器， 标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除 ，收集结束会产生大量空间碎片。 |
| G1                | 标记整理算法实现， 运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记 。 不会产生空间碎片，可以精确地控制停顿。 |



##### CMS收集器和G1收集器的区别

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用。G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以最小的停顿时间为目标的收集器。G1收集器可预测垃圾回收的停顿时间;
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片。G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

##### 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。

**类加载器**:类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

**启动类加载器**（Bootstrap ClassLoader）： 由C++语言实现（针对HotSpot）,负责将存放在lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。
**其他类加载器**： 由Java语言实现，继承自抽象类ClassLoader。 如：
**扩展类加载器**（Extension ClassLoader）： 负责加载libext目录或java.ext.dirs系统变量指定的路径中的所有类库。
**应用程序类加载器**（Application ClassLoader）。 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。 一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

##### 垃圾回收对象时程序的逻辑是否可以继续执行

不同回收器不同：Serial、ParNew会暂停用户所有线程工作；CMS、G1会在某一阶段暂停用户线程。

##### 内存分配策略

- 对象优先在Eden分配：若Eden无空间，Java虚拟机发起一次Minor GC。
- 大对象直接进入老年代：大对象指需要大量连续内存空间的对象（如长数组、长字符串）
- 长期存活的对象进入老年代：每个对象有一个对象年龄计数器，age=15晋升为老年代。age+1的两个情况：对象在Eden出生并经过一次Minor GC存活且被survivor容纳；在survivor区经历过一次minor GC。

##### 空间分配担保

- 在Minor GC之前，先检查老年代最大可用连续空间是否大于新生代所有空间总和，成立则此次GC安全
- 不成立，查看是否允许担保失败设置为true，不允许则进行Full GC
- 允许，看老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，不成立则Full GC
- 成立，则进行Minor GC

##### java中方法区存放哪些东西？jvm如何控制方法区的大小以及内存溢出的原因和解决

方法区大小不是固定的，jvm可根据需要动态调整。方法区主要存放类信息、常量、静态变量、编译后的代码。

控制方法区大小：减少程序中class数量、尽量使用较少的静态变量，减少动态代理等操作

修改：-XX:MaxPerSize调大(1.8以后是元数据区，和直接内存有关)

StackOverflowError异常：线程的方法嵌套调用层次太多，随着Java栈中桢的增多，最终会由于该线程Java栈中所有栈帧总和大于-Xss设置的值而产生此异常。

##### 可以作为GC Root的对象：

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中Native方法引用的对象

### 设计模式

#### 单例模式

#### 工厂模式

#### 代理模式

#### 模板模式

#### 策略模式

## 数据库

### Mysql

#### 基础SQL语句

#### SQL调优

#### 存储引擎

#### 事务隔离级别

#### 读写分离

#### 分库分表

### Redis

#### Redis数据结构

#### Redis内部原理

##### LRU实现算法

#### 分布式Redis

#### Redis使用场景

##### 分布式缓存

##### 分布式锁

### MongoDB

#### 使用场景
* 日志记录
* 快递应用、空间(位置)查找
* 游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新
* 物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。
* 社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能
* 物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析
* 视频直播，使用 MongoDB 存储用户信息、礼物信息等

#### 分片

#### 副本集

## 框架源码

### Spring

#### IOC

#### DI

#### AOP

#### MVC

#### 事务
##### 事务的基本原理
Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无
法提供事务功能的。对于纯 JDBC 操作数据库，想要用到事务，可以按照以下步骤进行:

1. 获取连接 Connection con = DriverManager.getConnection()
2. 开启事务 con.setAutoCommit(true/false);
3. 执行 CRUD;
4. 提交事务/回滚事务 con.commit() / con.rollback();
5. 关闭连接 conn.close();

使用Spring的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由Spirng 自
动完成。  那么 Spring 是如何在我们书写的 CRUD 之前和之后开启事务和关闭事务的
呢？解决这个问题，也就可以从整体上理解 Spring 的事务管理实现原理了。下面简单地
介绍下，注解方式为例子
配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional 标识。
Spring 在启动的时候会去解析生成相关的 bean，这时候会查看拥有相关注解的类和方
法，并且为这些类和方法生成代理，并根据@Transaction 的相关参数进行相关配置注入，
这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。
真正的数据库层的事务提交和回滚是通过 binlog 或者 redo log 实现的。

##### Spring 事务的传播属性

所谓 spring 事务的传播属性，就是定义在存在多个事务同时存在的时候，spring 应该如
何处理这些事务的行为。这些属性在 TransactionDefinition 中定义，具体常量的解释见
下表：

| 常量名称                  | 常量解释                                                     |
| ------------------------- | ------------------------------------------------------------ |
| PROPAGATION_REQUIRED      | 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring默认的事务的传播。 |
| PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作 |
| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，就以非事务方式执行。         |
| PROPAGATION_MANDATORY     | 支持当前事务，如果当前没有事务，就抛出异常。                 |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   |
| PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常。             |
| PROPAGATION_NESTED        | 如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED 属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager 事务管理器起效。 |

##### 数据库隔离级别

| 隔离级别         | 隔离级别的值 | 导致的问题 |
| ---------------- | ------------ | ---------- |
| Read-Uncommitted | 0            | 脏读       |
| Read-Committed   | 1            | 避免脏读，存在不可重复读和幻读           |
| Repeatable-Read  | 2             | 避免脏读和不可重复读，存在幻读 |
|                  |              |            |



#### ORM

### SpringMVC

#### 配置阶段流程

#### 运行阶段流程

### MyBatis

#### 原理

#### 插件

### SpringBoot

#### 优点

#### 相应注解

## 分布式

### 高并发

### 消息队列

### 缓存

### 分布式事务

### 分布式锁

#### 分库分表

## 微服务

### 服务拆分

### 服务治理

#### RPC

### 注册中心

### 降级

### 限流

### 熔断



## 其他

### 中台



